#!/usr/bin/env bash
set -e

# Default PROJECT_DIR to parent of install/ when unset (e.g. dev: run from repo root without env)
if [[ -z "${PROJECT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
    PROJECT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
fi

PLUGINS_DIR="$PROJECT_DIR/src/plugins"

command="${1:-}"
shift || true

usage() {
    echo ""
    echo "Plugin commands:"
    echo "  inkypi plugin install <plugin_id> <git_repository_url>"
    echo "  inkypi plugin install-from-url <git_repository_url>"
    echo "  inkypi plugin uninstall <plugin_id>"
    echo "  inkypi plugin list"
    echo ""
}

require_plugins_dir() {
    if [[ ! -d "$PLUGINS_DIR" ]]; then
        echo "Plugins directory does not exist: $PLUGINS_DIR"
        exit 1
    fi
}

# Remove a plugin directory; on permission failure print clear error and exit.
# Call only when the directory is safe to remove (e.g. plugin dir in PLUGINS_DIR).
# In dev (APPNAME unset) we skip sudo to avoid password prompt when run from the UI.
try_remove_plugin_dir() {
    local dir="$1"
    [[ -z "$dir" ]] && return 1
    if [[ -n "${APPNAME:-}" ]]; then
        sudo chown -R "$(whoami)":"$(whoami)" "$dir" 2>/dev/null || true
    fi
    chmod -R u+rw "$dir" 2>/dev/null || true
    rm -rf "$dir" 2>/dev/null || true
    if [[ -d "$dir" ]]; then
        echo "[ERROR] Could not remove directory (permission denied): $dir"
        echo "Try from a terminal: sudo rm -rf $dir"
        exit 1
    fi
}

# ----------------------------
# INSTALL
# ----------------------------
install_plugin() {
    if [[ $# -ne 2 ]]; then
        usage
        exit 1
    fi

    PLUGIN_ID="$1"
    REPO_URL="$2"
    DEST_DIR="$PLUGINS_DIR/$PLUGIN_ID"

    require_plugins_dir

    echo "[INFO] Installing plugin '$PLUGIN_ID' from $REPO_URL"

    if [[ -d "$DEST_DIR" ]]; then
        try_remove_plugin_dir "$DEST_DIR"
    fi
    mkdir -p "$DEST_DIR"

    git clone --depth 1 --filter=blob:none --sparse "$REPO_URL" "$DEST_DIR" &>/dev/null

    # Check if the folder exists in the branch
    DEFAULT_BRANCH=$(git -C "$DEST_DIR" symbolic-ref --short HEAD 2>/dev/null || echo main)
    if ! git -C "$DEST_DIR" ls-tree --name-only "$DEFAULT_BRANCH" | grep -qx "$PLUGIN_ID"; then
        echo "[INFO] Plugin '$PLUGIN_ID' does not exist in the repo"
        try_remove_plugin_dir "$DEST_DIR"
        exit 1
    fi

    cd "$DEST_DIR"
    git sparse-checkout set "$PLUGIN_ID" &>/dev/null

    # Move plugin files to root of DEST_DIR
    shopt -s dotglob
    mv "$PLUGIN_ID"/* ./
    rm -rf "$PLUGIN_ID"

    echo "[INFO] Plugin copied to $DEST_DIR"
   
    # Record install URL in plugin-info.json so "list" shows third_party so we do not rely on plugin having a repository field in plugin-info.json
    if [[ -f "$DEST_DIR/plugin-info.json" ]] && command -v jq &>/dev/null; then
        jq --arg url "$REPO_URL" '.repository = $url' "$DEST_DIR/plugin-info.json" > "$DEST_DIR/plugin-info.json.tmp" && mv "$DEST_DIR/plugin-info.json.tmp" "$DEST_DIR/plugin-info.json"
    fi

    # Install requirements if any (skip when VENV_PATH unset, e.g. in dev)
    REQ_FILE="$DEST_DIR/requirements.txt"

    if [[ -f "$REQ_FILE" ]]; then
        if [[ -n "${VENV_PATH:-}" ]] && [[ -d "$VENV_PATH" ]]; then
            echo "[INFO] requirements.txt found, installing dependencies..."
            source "$VENV_PATH/bin/activate"
            pip install -r "$REQ_FILE"
            deactivate
            echo "[INFO] Dependencies installed"
        else
            echo "[INFO] requirements.txt found but VENV_PATH not set or missing, skipping dependency install"
        fi
    else
        echo "[INFO] No requirements.txt found, skipping dependency install"
    fi

    if [[ -n "${APPNAME:-}" ]]; then
        echo "[INFO] Restarting $APPNAME service."
        sudo systemctl restart "$APPNAME.service" 2>&1 || echo "[WARN] Service restart failed, but plugin is installed"
    else
        echo "[INFO] APPNAME not set, skipping service restart (e.g. development mode)"
    fi

    echo "[INFO] Done"
}

# ----------------------------
# INSTALL FROM URL (discover plugin id from repo)
# ----------------------------
install_from_url() {
    if [[ $# -ne 1 ]]; then
        usage
        exit 1
    fi

    REPO_URL="$1"
    require_plugins_dir

    if ! command -v jq &>/dev/null; then
        echo "[ERROR] jq is required for install-from-url. Please install jq."
        exit 1
    fi

    TMP_DIR="$(mktemp -d)"
    trap 'rm -rf "$TMP_DIR"' EXIT

    echo "[INFO] Cloning repository to discover plugin..."
    if ! git clone --depth 1 "$REPO_URL" "$TMP_DIR" &>/dev/null; then
        echo "[ERROR] Failed to clone repository: $REPO_URL"
        exit 1
    fi

    PLUGIN_FOLDER=""
    FOUND_COUNT=0

    for dir in "$TMP_DIR"/*; do
        [[ -d "$dir" ]] || continue
        dirname="$(basename "$dir")"
        [[ "$dirname" == ".git" ]] && continue
        if [[ -d "$dir/render" ]] && [[ -f "$dir/plugin-info.json" ]]; then
            if [[ -n "$(jq -r '.id // empty' "$dir/plugin-info.json")" ]]; then
                PLUGIN_FOLDER="$dirname"
                (( FOUND_COUNT++ )) || true
            fi
        fi
    done

    if [[ $FOUND_COUNT -eq 0 ]]; then
        echo "[ERROR] No valid InkyPi plugin found in repository (need a folder containing render/ and plugin-info.json with id)"
        exit 1
    fi

    if [[ $FOUND_COUNT -gt 1 ]]; then
        echo "[ERROR] Multiple plugin folders found in repository; use 'install <plugin_id> <url>' to specify which one"
        exit 1
    fi

    install_plugin "$PLUGIN_FOLDER" "$REPO_URL"
}

# ----------------------------
# REMOVE
# ----------------------------
uninstall_plugin() {
    if [[ $# -ne 1 ]]; then
        usage
        exit 1
    fi

    PLUGIN_ID="$1"
    DEST_DIR="$PLUGINS_DIR/$PLUGIN_ID"

    require_plugins_dir

    if [[ ! -d "$DEST_DIR" ]]; then
        echo "[ERROR] Plugin '$PLUGIN_ID' is not installed."
        exit 1
    fi

    echo "[INFO] Removing plugin '$PLUGIN_ID'"

    try_remove_plugin_dir "$DEST_DIR"

    echo "[INFO] Plugin successfully uninstalled"

    if [[ -n "${APPNAME:-}" ]]; then
        echo "[INFO] Restarting $APPNAME service."
        sudo systemctl restart "$APPNAME.service" 2>&1 || echo "[WARN] Service restart failed, but plugin is uninstalled"
    else
        echo "[INFO] APPNAME not set, skipping service restart (e.g. development mode)"
    fi
}

# ----------------------------
# LIST
# ----------------------------
list_plugins() {
    require_plugins_dir
    {
        printf "PLUGIN\tNAME\tTYPE\tREPOSITORY\n"

        for plugin_dir in "$PLUGINS_DIR"/*; do
            plugin_id="$(basename "$plugin_dir")"
            [[ "$plugin_id" == "base_plugin" ]] && continue

            info_file="$plugin_dir/plugin-info.json"
            [[ ! -f "$info_file" ]] && continue

            # Extract name + repository
            IFS=$'\t' read -r name repo < <(
                jq -r '[.display_name, .repository] | map(. // "") | @tsv' "$info_file"
            )

            # Infer type from repository presence
            if [[ -n "$repo" ]]; then
                type="third_party"
            else
                type="builtin"
                repo="-"
            fi

            printf "%s\t%s\t%s\t%s\n" \
                "$plugin_id" "$name" "$type" "$repo"
        done
    } | column -t -s $'\t'
}
# ----------------------------
# COMMAND ROUTER
# ----------------------------

case "$command" in
    install)
        install_plugin "$@"
        ;;
    install-from-url)
        install_from_url "$@"
        ;;
    uninstall)
        uninstall_plugin "$@"
        ;;
    list)
        list_plugins
        ;;
    ""|-h|--help|help)
        usage
        ;;
    *)
        echo "[ERROR] Unknown command: $command"
        usage
        exit 1
        ;;
esac
